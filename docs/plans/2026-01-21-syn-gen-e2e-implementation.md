# syn-gen End-to-End Testing Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create automated end-to-end tests that verify CRISPResso correctly detects synthetic edits generated by syn-gen, running in GitHub Actions on each push.

**Architecture:** Tests follow a generate â†’ run â†’ verify pattern. syn-gen creates FASTQ with known edits, CRISPResso analyzes it, then we parse `Alleles_frequency_table.zip` and compare against syn-gen's ground truth TSV. Random seeds are logged for reproducibility.

**Tech Stack:** Python, pytest, hypothesis, CRISPResso2 (bioconda), GitHub Actions with conda-incubator/setup-miniconda

---

## Task 1: Create pytest Configuration with --seed Option

**Files:**
- Create: `syn-gen/conftest.py`

**Step 1: Write the conftest.py file**

```python
"""pytest configuration for syn-gen tests."""

import random
import pytest


def pytest_addoption(parser):
    """Add custom command line options."""
    parser.addoption(
        "--seed",
        action="store",
        default=None,
        type=int,
        help="Random seed for reproducibility. If not provided, a random seed is generated.",
    )


@pytest.fixture
def random_seed(request):
    """
    Fixture providing a random seed for tests.

    Uses --seed if provided, otherwise generates a random seed.
    The seed is always printed for reproducibility on failure.
    """
    seed = request.config.getoption("--seed")
    if seed is None:
        seed = random.randint(0, 2**31 - 1)
    print(f"\n=== Test seed: {seed} ===")
    return seed
```

**Step 2: Verify conftest.py is recognized**

Run: `cd syn-gen && pytest --co -q 2>&1 | head -5`
Expected: No errors, shows collected tests

**Step 3: Commit**

```bash
git add syn-gen/conftest.py
git commit -m "feat(syn-gen): add pytest conftest with --seed option

Allows reproducible random seeds for e2e tests. Seeds are logged
for debugging test failures.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 2: Create E2E Test File Skeleton with Fixtures

**Files:**
- Create: `syn-gen/test_e2e.py`

**Step 1: Write the test file skeleton with shared fixtures**

```python
"""End-to-end tests for syn-gen + CRISPResso integration."""

import os
import random
import subprocess
import tempfile
import zipfile
from pathlib import Path

import pytest

from syn_gen import generate_synthetic_data


# =============================================================================
# Constants
# =============================================================================

# Standard test amplicon (from existing CRISPResso tests)
TEST_AMPLICON = (
    "CGGATGTTCCAATCAGTACGCAGAGAGTCGCCGTCTCCAAGGTGAAAGCGGAAGTAGGGCCTTCGCGCACCTCAT"
    "GGAATCCCTTCTGCAGCACCTGGATCGCTTTTCCGAGCTTCTGGCGGTCTCAAGCACTACCTACGTCAGCACCTG"
    "GGACCCCGCCACCGTGCGCCGGGCCTTGCAGTGGGCGCGCTACCTGCGCCACATCCATCGGCGCTTTGGTCGG"
)

TEST_GUIDE = "GGAATCCCTTCTGCAGCACC"

# Prime editing parameters (from existing tests)
PE_EXTENSION = "ATCTGGATCGGCTGCAGAAGGGA"
PE_SCAFFOLD = "GTTTTAGAGCTAGAAATAGCAAGTTAAAATAAGGCTAGTCCGTTATCAACTTGAAAAAGTGGCACCGAGTCGGTGC"


# =============================================================================
# Fixtures
# =============================================================================

@pytest.fixture
def temp_dir():
    """Create a temporary directory for test outputs."""
    with tempfile.TemporaryDirectory() as tmpdir:
        yield tmpdir


@pytest.fixture
def crispresso_available():
    """Check if CRISPResso is available in PATH."""
    result = subprocess.run(
        ["which", "CRISPResso"],
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        pytest.skip("CRISPResso not available in PATH")
    return True


# =============================================================================
# Helper Functions
# =============================================================================

def run_crispresso(
    fastq_path: str,
    output_dir: str,
    amplicon: str,
    guide: str,
    extra_args: list[str] = None,
) -> subprocess.CompletedProcess:
    """
    Run CRISPResso on the given FASTQ file.

    Args:
        fastq_path: Path to input FASTQ file
        output_dir: Directory for CRISPResso output
        amplicon: Amplicon sequence
        guide: Guide sequence
        extra_args: Additional CRISPResso arguments

    Returns:
        CompletedProcess with stdout/stderr
    """
    cmd = [
        "CRISPResso",
        "-r1", fastq_path,
        "-a", amplicon,
        "-g", guide,
        "-o", output_dir,
        "--write_detailed_allele_table",
        "--place_report_in_output_folder",
        "-w", "20",  # quantification window size
        "-q", "0",   # no quality filtering (synthetic data is perfect)
    ]
    if extra_args:
        cmd.extend(extra_args)

    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        timeout=300,  # 5 minute timeout
    )
    return result


def parse_alleles_table(crispresso_output_dir: str) -> list[dict]:
    """
    Parse Alleles_frequency_table.zip from CRISPResso output.

    Args:
        crispresso_output_dir: Path to CRISPResso output directory

    Returns:
        List of dicts with allele information
    """
    # Find the CRISPResso output folder (named CRISPResso_on_*)
    output_folders = [
        d for d in os.listdir(crispresso_output_dir)
        if d.startswith("CRISPResso_on_")
    ]
    if not output_folders:
        raise FileNotFoundError(f"No CRISPResso output folder in {crispresso_output_dir}")

    crispresso_folder = os.path.join(crispresso_output_dir, output_folders[0])
    zip_path = os.path.join(crispresso_folder, "Alleles_frequency_table.zip")

    if not os.path.exists(zip_path):
        raise FileNotFoundError(f"Alleles_frequency_table.zip not found in {crispresso_folder}")

    alleles = []
    with zipfile.ZipFile(zip_path, 'r') as zf:
        # Find the TSV file inside the zip
        tsv_files = [f for f in zf.namelist() if f.endswith('.txt')]
        if not tsv_files:
            raise FileNotFoundError("No .txt file in Alleles_frequency_table.zip")

        with zf.open(tsv_files[0]) as f:
            lines = f.read().decode('utf-8').strip().split('\n')
            if len(lines) < 2:
                return alleles

            header = lines[0].split('\t')
            for line in lines[1:]:
                values = line.split('\t')
                allele = dict(zip(header, values))
                alleles.append(allele)

    return alleles


def parse_edits_tsv(tsv_path: str) -> list[dict]:
    """
    Parse syn-gen's *_edits.tsv ground truth file.

    Args:
        tsv_path: Path to edits TSV file

    Returns:
        List of dicts with edit information per read
    """
    edits = []
    with open(tsv_path) as f:
        lines = f.read().strip().split('\n')
        if len(lines) < 2:
            return edits

        header = lines[0].split('\t')
        for line in lines[1:]:
            values = line.split('\t')
            edit = dict(zip(header, values))
            edits.append(edit)

    return edits


# =============================================================================
# Test Classes (placeholders for subsequent tasks)
# =============================================================================

class TestNHEJEndToEnd:
    """End-to-end tests for NHEJ editing mode."""
    pass


class TestBaseEditingEndToEnd:
    """End-to-end tests for base editing mode."""
    pass


class TestPrimeEditingEndToEnd:
    """End-to-end tests for prime editing mode."""
    pass
```

**Step 2: Verify the test file is valid Python**

Run: `cd syn-gen && python -c "import test_e2e; print('OK')"`
Expected: `OK`

**Step 3: Commit**

```bash
git add syn-gen/test_e2e.py
git commit -m "feat(syn-gen): add e2e test skeleton with fixtures and helpers

Includes:
- Shared test constants (amplicon, guide)
- temp_dir and crispresso_available fixtures
- run_crispresso helper function
- parse_alleles_table to read CRISPResso output
- parse_edits_tsv to read syn-gen ground truth
- Placeholder test classes for each editing mode

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 3: Implement NHEJ End-to-End Tests

**Files:**
- Modify: `syn-gen/test_e2e.py`

**Step 1: Write the NHEJ test class**

Replace the `TestNHEJEndToEnd` placeholder with:

```python
class TestNHEJEndToEnd:
    """End-to-end tests for NHEJ editing mode."""

    def test_nhej_basic(self, temp_dir, random_seed, crispresso_available):
        """
        Test that CRISPResso correctly detects NHEJ edits (deletions/insertions).

        Generates synthetic data with 50% edit rate, runs CRISPResso,
        and verifies the detected edit counts match the ground truth.
        """
        random.seed(random_seed)

        # Generate synthetic data
        output_prefix = os.path.join(temp_dir, "nhej_test")
        stats = generate_synthetic_data(
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            num_reads=1000,
            edit_rate=0.5,
            error_rate=0.0,  # No sequencing errors for exact matching
            output_prefix=output_prefix,
            seed=random_seed,
            quiet=True,
            mode='nhej',
        )

        fastq_path = f"{output_prefix}.fastq"
        edits_path = f"{output_prefix}_edits.tsv"

        # Run CRISPResso
        result = run_crispresso(
            fastq_path=fastq_path,
            output_dir=temp_dir,
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
        )

        # Check CRISPResso ran successfully
        assert result.returncode == 0, f"CRISPResso failed: {result.stderr}"

        # Parse results
        ground_truth = parse_edits_tsv(edits_path)
        alleles = parse_alleles_table(temp_dir)

        # Count edits in ground truth
        gt_edited = sum(1 for e in ground_truth if e['edit_type'] != 'none')
        gt_unedited = sum(1 for e in ground_truth if e['edit_type'] == 'none')

        # Count total reads in CRISPResso output
        total_crispresso_reads = sum(int(a.get('#Reads', a.get('Reads', 0))) for a in alleles)

        # Verify total read count matches
        assert total_crispresso_reads == 1000, (
            f"Read count mismatch: CRISPResso={total_crispresso_reads}, expected=1000"
        )

        # Find reference allele (unedited) in CRISPResso output
        ref_reads = 0
        for allele in alleles:
            n_deleted = int(allele.get('n_deleted', 0))
            n_inserted = int(allele.get('n_inserted', 0))
            n_mutated = int(allele.get('n_mutated', 0))
            if n_deleted == 0 and n_inserted == 0 and n_mutated == 0:
                ref_reads += int(allele.get('#Reads', allele.get('Reads', 0)))

        # Verify unedited count is close to ground truth (allow 5% tolerance)
        tolerance = 0.05 * 1000
        assert abs(ref_reads - gt_unedited) <= tolerance, (
            f"Unedited count mismatch: CRISPResso={ref_reads}, ground_truth={gt_unedited}"
        )

        # Verify edited count
        edited_reads = total_crispresso_reads - ref_reads
        assert abs(edited_reads - gt_edited) <= tolerance, (
            f"Edited count mismatch: CRISPResso={edited_reads}, ground_truth={gt_edited}"
        )

    def test_nhej_deletions_detected(self, temp_dir, random_seed, crispresso_available):
        """Test that deletions are correctly detected by CRISPResso."""
        random.seed(random_seed)

        output_prefix = os.path.join(temp_dir, "nhej_del_test")
        stats = generate_synthetic_data(
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            num_reads=500,
            edit_rate=1.0,  # All reads edited
            error_rate=0.0,
            output_prefix=output_prefix,
            seed=random_seed,
            quiet=True,
            mode='nhej',
        )

        fastq_path = f"{output_prefix}.fastq"
        edits_path = f"{output_prefix}_edits.tsv"

        result = run_crispresso(
            fastq_path=fastq_path,
            output_dir=temp_dir,
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
        )

        assert result.returncode == 0, f"CRISPResso failed: {result.stderr}"

        ground_truth = parse_edits_tsv(edits_path)
        alleles = parse_alleles_table(temp_dir)

        # Count deletions in ground truth
        gt_deletions = sum(1 for e in ground_truth if e['edit_type'] == 'deletion')

        # Count reads with deletions in CRISPResso
        crispresso_deletions = sum(
            int(a.get('#Reads', a.get('Reads', 0)))
            for a in alleles
            if int(a.get('n_deleted', 0)) > 0
        )

        # Verify deletion detection (allow 10% tolerance due to alignment differences)
        tolerance = 0.10 * 500
        assert abs(crispresso_deletions - gt_deletions) <= tolerance, (
            f"Deletion count mismatch: CRISPResso={crispresso_deletions}, ground_truth={gt_deletions}"
        )
```

**Step 2: Run the NHEJ tests (requires CRISPResso)**

Run: `cd syn-gen && pytest test_e2e.py::TestNHEJEndToEnd -v --tb=short`
Expected: Tests pass (or skip if CRISPResso not available)

**Step 3: Commit**

```bash
git add syn-gen/test_e2e.py
git commit -m "feat(syn-gen): implement NHEJ end-to-end tests

Tests verify CRISPResso correctly detects:
- Overall edit vs unedited read counts
- Deletion detection accuracy

Uses 1000 reads with 50% edit rate for basic test,
500 reads with 100% edit rate for deletion detection.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 4: Implement Base Editing End-to-End Tests

**Files:**
- Modify: `syn-gen/test_e2e.py`

**Step 1: Write the base editing test class**

Replace the `TestBaseEditingEndToEnd` placeholder with:

```python
class TestBaseEditingEndToEnd:
    """End-to-end tests for base editing mode (CBE and ABE)."""

    def test_cbe_basic(self, temp_dir, random_seed, crispresso_available):
        """
        Test that CRISPResso correctly detects CBE edits (Câ†’T conversions).
        """
        random.seed(random_seed)

        output_prefix = os.path.join(temp_dir, "cbe_test")
        stats = generate_synthetic_data(
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            num_reads=1000,
            edit_rate=0.5,
            error_rate=0.0,
            output_prefix=output_prefix,
            seed=random_seed,
            quiet=True,
            mode='base-edit',
            base_editor='CBE',
            window_center=6,
            window_sigma=1.5,
            base_edit_prob=0.8,  # High conversion probability
        )

        fastq_path = f"{output_prefix}.fastq"
        edits_path = f"{output_prefix}_edits.tsv"

        result = run_crispresso(
            fastq_path=fastq_path,
            output_dir=temp_dir,
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            extra_args=["--base_editor_output"],
        )

        assert result.returncode == 0, f"CRISPResso failed: {result.stderr}"

        ground_truth = parse_edits_tsv(edits_path)
        alleles = parse_alleles_table(temp_dir)

        # Count substitutions in ground truth
        gt_substitutions = sum(1 for e in ground_truth if e['edit_type'] == 'substitution')

        # Count reads with mutations in CRISPResso
        crispresso_mutated = sum(
            int(a.get('#Reads', a.get('Reads', 0)))
            for a in alleles
            if int(a.get('n_mutated', 0)) > 0
        )

        # Verify substitution detection (allow 15% tolerance)
        tolerance = 0.15 * 1000
        assert abs(crispresso_mutated - gt_substitutions) <= tolerance, (
            f"Substitution count mismatch: CRISPResso={crispresso_mutated}, ground_truth={gt_substitutions}"
        )

    def test_abe_basic(self, temp_dir, random_seed, crispresso_available):
        """
        Test that CRISPResso correctly detects ABE edits (Aâ†’G conversions).
        """
        random.seed(random_seed)

        output_prefix = os.path.join(temp_dir, "abe_test")
        stats = generate_synthetic_data(
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            num_reads=1000,
            edit_rate=0.5,
            error_rate=0.0,
            output_prefix=output_prefix,
            seed=random_seed,
            quiet=True,
            mode='base-edit',
            base_editor='ABE',
            window_center=6,
            window_sigma=1.5,
            base_edit_prob=0.8,
        )

        fastq_path = f"{output_prefix}.fastq"
        edits_path = f"{output_prefix}_edits.tsv"

        result = run_crispresso(
            fastq_path=fastq_path,
            output_dir=temp_dir,
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            extra_args=["--base_editor_output"],
        )

        assert result.returncode == 0, f"CRISPResso failed: {result.stderr}"

        ground_truth = parse_edits_tsv(edits_path)
        alleles = parse_alleles_table(temp_dir)

        gt_substitutions = sum(1 for e in ground_truth if e['edit_type'] == 'substitution')

        crispresso_mutated = sum(
            int(a.get('#Reads', a.get('Reads', 0)))
            for a in alleles
            if int(a.get('n_mutated', 0)) > 0
        )

        tolerance = 0.15 * 1000
        assert abs(crispresso_mutated - gt_substitutions) <= tolerance, (
            f"ABE substitution count mismatch: CRISPResso={crispresso_mutated}, ground_truth={gt_substitutions}"
        )
```

**Step 2: Run the base editing tests**

Run: `cd syn-gen && pytest test_e2e.py::TestBaseEditingEndToEnd -v --tb=short`
Expected: Tests pass (or skip if CRISPResso not available)

**Step 3: Commit**

```bash
git add syn-gen/test_e2e.py
git commit -m "feat(syn-gen): implement base editing end-to-end tests

Tests verify CRISPResso correctly detects:
- CBE (Câ†’T) substitutions
- ABE (Aâ†’G) substitutions

Uses --base_editor_output flag for proper base editing analysis.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 5: Implement Prime Editing End-to-End Tests

**Files:**
- Modify: `syn-gen/test_e2e.py`

**Step 1: Write the prime editing test class**

Replace the `TestPrimeEditingEndToEnd` placeholder with:

```python
class TestPrimeEditingEndToEnd:
    """End-to-end tests for prime editing mode."""

    def test_prime_edit_basic(self, temp_dir, random_seed, crispresso_available):
        """
        Test that CRISPResso correctly detects prime editing outcomes.
        """
        random.seed(random_seed)

        output_prefix = os.path.join(temp_dir, "pe_test")
        stats = generate_synthetic_data(
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            num_reads=1000,
            edit_rate=0.5,
            error_rate=0.0,
            output_prefix=output_prefix,
            seed=random_seed,
            quiet=True,
            mode='prime-edit',
            peg_extension=PE_EXTENSION,
            peg_scaffold=PE_SCAFFOLD,
            perfect_edit_fraction=0.8,  # Mostly perfect edits for cleaner validation
            partial_edit_fraction=0.1,
            pe_indel_fraction=0.1,
            scaffold_incorporation_fraction=0.0,
            flap_indel_fraction=0.0,
        )

        fastq_path = f"{output_prefix}.fastq"
        edits_path = f"{output_prefix}_edits.tsv"

        result = run_crispresso(
            fastq_path=fastq_path,
            output_dir=temp_dir,
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            extra_args=[
                "--prime_editing_pegRNA_spacer_seq", TEST_GUIDE,
                "--prime_editing_pegRNA_extension_seq", PE_EXTENSION,
                "--prime_editing_pegRNA_scaffold_seq", PE_SCAFFOLD,
            ],
        )

        assert result.returncode == 0, f"CRISPResso failed: {result.stderr}"

        ground_truth = parse_edits_tsv(edits_path)
        alleles = parse_alleles_table(temp_dir)

        # Count prime edits in ground truth
        gt_prime_edits = sum(1 for e in ground_truth if e['edit_type'] == 'prime_edit')
        gt_unedited = sum(1 for e in ground_truth if e['edit_type'] == 'none')

        # Count total reads
        total_crispresso_reads = sum(int(a.get('#Reads', a.get('Reads', 0))) for a in alleles)

        # Verify total read count
        assert total_crispresso_reads == 1000, (
            f"Read count mismatch: CRISPResso={total_crispresso_reads}, expected=1000"
        )

        # Find unedited (reference) reads
        ref_reads = 0
        for allele in alleles:
            n_deleted = int(allele.get('n_deleted', 0))
            n_inserted = int(allele.get('n_inserted', 0))
            n_mutated = int(allele.get('n_mutated', 0))
            if n_deleted == 0 and n_inserted == 0 and n_mutated == 0:
                ref_reads += int(allele.get('#Reads', allele.get('Reads', 0)))

        # Verify unedited count (allow 10% tolerance)
        tolerance = 0.10 * 1000
        assert abs(ref_reads - gt_unedited) <= tolerance, (
            f"Unedited count mismatch: CRISPResso={ref_reads}, ground_truth={gt_unedited}"
        )

    def test_prime_edit_perfect_edits(self, temp_dir, random_seed, crispresso_available):
        """Test that perfect prime edits are detected with correct sequence."""
        random.seed(random_seed)

        output_prefix = os.path.join(temp_dir, "pe_perfect_test")
        stats = generate_synthetic_data(
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            num_reads=500,
            edit_rate=1.0,  # All reads edited
            error_rate=0.0,
            output_prefix=output_prefix,
            seed=random_seed,
            quiet=True,
            mode='prime-edit',
            peg_extension=PE_EXTENSION,
            peg_scaffold=PE_SCAFFOLD,
            perfect_edit_fraction=1.0,  # All perfect edits
            partial_edit_fraction=0.0,
            pe_indel_fraction=0.0,
            scaffold_incorporation_fraction=0.0,
            flap_indel_fraction=0.0,
        )

        fastq_path = f"{output_prefix}.fastq"

        result = run_crispresso(
            fastq_path=fastq_path,
            output_dir=temp_dir,
            amplicon=TEST_AMPLICON,
            guide=TEST_GUIDE,
            extra_args=[
                "--prime_editing_pegRNA_spacer_seq", TEST_GUIDE,
                "--prime_editing_pegRNA_extension_seq", PE_EXTENSION,
                "--prime_editing_pegRNA_scaffold_seq", PE_SCAFFOLD,
            ],
        )

        assert result.returncode == 0, f"CRISPResso failed: {result.stderr}"

        alleles = parse_alleles_table(temp_dir)

        # All reads should show edits (no unedited reads)
        ref_reads = 0
        for allele in alleles:
            n_deleted = int(allele.get('n_deleted', 0))
            n_inserted = int(allele.get('n_inserted', 0))
            n_mutated = int(allele.get('n_mutated', 0))
            if n_deleted == 0 and n_inserted == 0 and n_mutated == 0:
                ref_reads += int(allele.get('#Reads', allele.get('Reads', 0)))

        # Allow small tolerance for alignment edge cases
        assert ref_reads <= 25, (
            f"Too many unedited reads detected: {ref_reads} (expected ~0)"
        )
```

**Step 2: Run the prime editing tests**

Run: `cd syn-gen && pytest test_e2e.py::TestPrimeEditingEndToEnd -v --tb=short`
Expected: Tests pass (or skip if CRISPResso not available)

**Step 3: Commit**

```bash
git add syn-gen/test_e2e.py
git commit -m "feat(syn-gen): implement prime editing end-to-end tests

Tests verify CRISPResso correctly detects:
- Prime editing outcomes (edited vs unedited counts)
- Perfect prime edits with correct sequence changes

Uses prime editing specific CRISPResso flags.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 6: Create GitHub Actions Workflow

**Files:**
- Create: `.github/workflows/syn-gen-tests.yml`

**Step 1: Create the workflow directory**

Run: `mkdir -p .github/workflows`

**Step 2: Write the workflow file**

```yaml
name: syn-gen tests

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    defaults:
      run:
        shell: bash -l {0}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Miniconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-update-conda: true
          python-version: "3.10"
          channels: bioconda,conda-forge,defaults
          channel-priority: strict

      - name: Cache conda environment
        uses: actions/cache@v4
        with:
          path: ~/conda_pkgs_dir
          key: ${{ runner.os }}-conda-${{ hashFiles('.github/workflows/syn-gen-tests.yml') }}
          restore-keys: |
            ${{ runner.os }}-conda-

      - name: Install CRISPResso2
        run: |
          conda install -y -c bioconda crispresso2
          CRISPResso --version

      - name: Install test dependencies
        run: |
          pip install pytest hypothesis

      - name: Run unit tests
        run: |
          cd syn-gen && pytest test_syn_gen.py -v

      - name: Run end-to-end tests
        run: |
          cd syn-gen && pytest test_e2e.py -v

      - name: Upload test artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-outputs
          path: |
            syn-gen/*.fastq
            syn-gen/*.tsv
            syn-gen/*.vcf
          retention-days: 7
```

**Step 3: Verify YAML is valid**

Run: `python -c "import yaml; yaml.safe_load(open('.github/workflows/syn-gen-tests.yml'))"`
Expected: No errors

**Step 4: Commit**

```bash
git add .github/workflows/syn-gen-tests.yml
git commit -m "ci: add GitHub Actions workflow for syn-gen tests

Runs on push and PR to master/main:
- Unit tests (test_syn_gen.py)
- End-to-end tests (test_e2e.py)

Uses bioconda for CRISPResso2 installation.
Caches conda environment for faster runs.
Uploads artifacts on failure for debugging.

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 7: Update Makefile with E2E Test Target

**Files:**
- Modify: `Makefile`

**Step 1: Add e2e test target**

Add after the `syn-gen-test` target:

```makefile
syn-gen-e2e:
	cd syn-gen && pytest test_e2e.py -v

syn-gen-all:
	cd syn-gen && pytest test_syn_gen.py test_e2e.py -v
```

**Step 2: Update the .PHONY line**

Add `syn-gen-e2e` and `syn-gen-all` to the .PHONY line at the top.

**Step 3: Verify Makefile works**

Run: `make syn-gen-test`
Expected: Unit tests run successfully

**Step 4: Commit**

```bash
git add Makefile
git commit -m "build: add syn-gen-e2e and syn-gen-all Makefile targets

- syn-gen-e2e: Run only end-to-end tests
- syn-gen-all: Run both unit and e2e tests

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>"
```

---

## Task 8: Final Integration Test and PR

**Step 1: Run all syn-gen tests**

Run: `make syn-gen-all`
Expected: All tests pass

**Step 2: Push branch**

```bash
git push -u origin feature/syn-gen-e2e
```

**Step 3: Create PR**

```bash
gh pr create --title "Add syn-gen end-to-end testing with GitHub Actions CI" --body "$(cat <<'EOF'
## Summary

- Add end-to-end tests for syn-gen that verify CRISPResso correctly detects synthetic edits
- Tests cover all three editing modes: NHEJ, base editing (CBE/ABE), and prime editing
- Add GitHub Actions workflow to run tests on every push

## Test Plan

- [x] Unit tests pass locally
- [x] E2E tests pass locally with CRISPResso installed
- [ ] GitHub Actions workflow runs successfully

## Details

The e2e tests follow a generate â†’ run â†’ verify pattern:
1. syn-gen creates FASTQ with known edits
2. CRISPResso analyzes the FASTQ
3. Tests parse `Alleles_frequency_table.zip` and compare against ground truth

Random seeds are logged for reproducibility. Use `pytest --seed=N` to reproduce failures.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```
